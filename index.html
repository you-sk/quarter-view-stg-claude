<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>クォータービューシューティング</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            text-align: center;
            position: relative;
        }
        
        #gameUI {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 90px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            transition: opacity 0.3s;
        }
        
        #gameUI.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
            outline: none;
        }
        
        #score {
            font-size: 18px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        
        #gameTitle {
            font-size: 16px;
            color: #4488ff;
            text-shadow: 0 0 8px #4488ff;
        }
        
        #controls {
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameUI">
            <div id="gameTitle">クォータービューシューティング</div>
            <div id="score">スコア: 0</div>
        </div>
        <canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>
        <div id="controls">
            WASD または 矢印キー: 移動 | スペース: 弾を撃つ
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ゲーム状態
        const GameState = {
            TITLE: 'title',
            PLAYING: 'playing', 
            GAMEOVER: 'gameover'
        };
        
        let currentState = GameState.TITLE;
        let score = 0;
        let finalScore = 0;
        
        // 入力状態
        const keys = {};
        
        // 自機
        const player = {
            x: canvas.width / 2,
            y: canvas.height * 0.8,
            size: 20,
            speed: 5
        };
        
        // 弾配列
        const bullets = [];
        
        // 敵配列
        const enemies = [];
        
        // パーティクル配列（爆発エフェクト用）
        const particles = [];
        
        // パースペクティブ設定
        const vanishingPoint = {
            x: canvas.width / 2,
            y: 50  // 画面上部の消失点
        };
        
        // 表示領域制限（UIエリアを避ける）
        const visibleArea = {
            top: 90,  // UIエリアの高さに合わせる
            bottom: canvas.height
        };
        
        // 疑似3D変換関数
        function get3DScale(y) {
            const minY = visibleArea.top;
            const maxY = canvas.height;
            const minScale = 0.3;
            const maxScale = 1.5;
            
            const normalizedY = (y - minY) / (maxY - minY);
            return Math.max(0.1, minScale + (maxScale - minScale) * normalizedY);
        }
        
        function get3DSpeed(y) {
            const scale = get3DScale(y);
            return scale;
        }
        
        // パースペクティブX座標計算
        function getPerspectiveX(startX, startY, currentY, convergenceRate = 0.3) {
            if (currentY <= vanishingPoint.y) return startX;
            
            const totalDistance = startY - vanishingPoint.y;
            const traveledDistance = startY - currentY;
            const progress = traveledDistance / totalDistance;
            
            return startX + (vanishingPoint.x - startX) * progress * convergenceRate;
        }
        
        // 表示領域内かどうかの判定
        function isInVisibleArea(y) {
            return y >= visibleArea.top;
        }
        
        // 弾クラス
        class Bullet {
            constructor(x, y) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.speed = 8;
                this.size = 4;
            }
            
            update() {
                this.y -= this.speed * get3DSpeed(this.y);
                this.x = getPerspectiveX(this.startX, this.startY, this.y, 0.7);
                return this.y > -10;
            }
            
            draw() {
                if (!isInVisibleArea(this.y)) return;
                
                const scale = get3DScale(this.y);
                const size = this.size * scale;
                
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
            }
            
            getBounds() {
                const scale = get3DScale(this.y);
                const size = this.size * scale;
                return {
                    x: this.x - size/2,
                    y: this.y - size/2,
                    width: size,
                    height: size
                };
            }
        }
        
        // 敵クラス
        class Enemy {
            constructor(x, y, type) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.type = type;
                this.speed = 2;
                this.size = 25;
                this.amplitude = 50;
                this.frequency = 0.05;
                this.time = 0;
            }
            
            update() {
                this.time += 1;
                this.y += this.speed * get3DSpeed(this.y);
                
                if (this.type === 0) {
                    this.x = getPerspectiveX(this.startX, this.startY, this.y, 0.3);
                } else if (this.type === 1) {
                    const baseX = getPerspectiveX(this.startX, this.startY, this.y, 0.3);
                    const swayAmount = Math.sin(this.time * this.frequency) * this.amplitude * get3DScale(this.y);
                    this.x = baseX + swayAmount;
                }
                
                return this.y < canvas.height + 50;
            }
            
            draw() {
                if (!isInVisibleArea(this.y)) return;
                
                const scale = get3DScale(this.y);
                
                ctx.fillStyle = this.type === 0 ? '#ff4444' : '#ff8844';
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(scale, scale);
                
                ctx.fillRect(-12, -8, 24, 16);
                ctx.fillRect(-16, -4, 8, 8);
                ctx.fillRect(8, -4, 8, 8);
                
                ctx.restore();
            }
            
            getBounds() {
                const scale = get3DScale(this.y);
                const size = this.size * scale;
                return {
                    x: this.x - size/2,
                    y: this.y - size/2,
                    width: size,
                    height: size
                };
            }
        }
        
        // パーティクルクラス
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30;
                this.maxLife = 30;
                this.size = Math.random() * 4 + 2;
                this.color = `hsl(${Math.random() * 60 + 10}, 100%, ${Math.random() * 50 + 50}%)`;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                const size = this.size * alpha;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
            }
        }
        
        // 爆発エフェクト生成
        function createExplosion(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push(new Particle(x, y));
            }
        }
        
        // 衝突判定
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // ゲームリセット
        function resetGame() {
            score = 0;
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;
            player.x = canvas.width / 2;
            player.y = canvas.height * 0.8;
            document.getElementById('score').textContent = `スコア: ${score}`;
        }
        
        // ゲーム開始
        function startGame() {
            console.log('Starting game!');
            resetGame();
            currentState = GameState.PLAYING;
        }
        
        // ゲームオーバー
        function gameOver() {
            finalScore = score;
            currentState = GameState.GAMEOVER;
        }
        
        // 敵生成
        function spawnEnemy() {
            const x = Math.random() * canvas.width;
            const y = visibleArea.top - 100;
            const type = Math.random() < 0.5 ? 0 : 1;
            enemies.push(new Enemy(x, y, type));
        }
        
        // タイトル画面描画
        function drawTitle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(1, '#004e92');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3;
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.8})`;
                ctx.fillRect(x, y, size, size);
            }
            
            ctx.fillStyle = '#4488ff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('quarter-stg', canvas.width/2, canvas.height/2 - 60);
            
            ctx.fillStyle = '#88ccff';
            ctx.font = '20px Arial';
            ctx.fillText('クォータービューシューティング', canvas.width/2, canvas.height/2 - 20);
            
            const time = Date.now() * 0.003;
            const alpha = (Math.sin(time) + 1) / 2;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.font = '18px Arial';
            ctx.fillText('クリックまたはキーを押してスタート', canvas.width/2, canvas.height/2 + 40);
            
            ctx.fillStyle = '#aaccff';
            ctx.font = '14px Arial';
            ctx.fillText('WASD / 矢印キー: 移動', canvas.width/2, canvas.height/2 + 100);
            ctx.fillText('スペース: 弾を撃つ', canvas.width/2, canvas.height/2 + 120);
        }
        
        // ゲームオーバー画面描画
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 60);
            
            ctx.fillStyle = '#ffff44';
            ctx.font = '24px Arial';
            ctx.fillText(`最終スコア: ${finalScore}`, canvas.width/2, canvas.height/2 - 10);
            
            const time = Date.now() * 0.003;
            const alpha = (Math.sin(time) + 1) / 2;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.font = '18px Arial';
            ctx.fillText('クリックまたはキーを押してリトライ', canvas.width/2, canvas.height/2 + 40);
        }
        
        // 自機描画
        function drawPlayer() {
            const scale = get3DScale(player.y);
            
            const centerX = canvas.width / 2;
            const offsetX = player.x - centerX;
            const maxOffset = canvas.width / 2;
            const tiltAngle = -(offsetX / maxOffset) * 0.3;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(tiltAngle);
            ctx.scale(scale, scale);
            
            ctx.fillStyle = '#4488ff';
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-10, 10);
            ctx.lineTo(10, 10);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#88ccff';
            ctx.fillRect(-8, 8, 16, 6);
            
            ctx.restore();
        }
        
        function handleInput() {
            if (currentState === GameState.PLAYING) {
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    player.x = Math.max(player.size/2, player.x - player.speed);
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    player.x = Math.min(canvas.width - player.size/2, player.x + player.speed);
                }
                if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                    player.y = Math.max(visibleArea.top + player.size/2, player.y - player.speed);
                }
                if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                    player.y = Math.min(canvas.height - player.size/2, player.y + player.speed);
                }
            }
        }
        
        function update() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (!bullets[i].update()) {
                    bullets.splice(i, 1);
                }
            }
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (!enemies[i].update()) {
                    enemies.splice(i, 1);
                }
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                }
            }
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[i].getBounds(), enemies[j].getBounds())) {
                        createExplosion(enemies[j].x, enemies[j].y);
                        
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        score += 100;
                        document.getElementById('score').textContent = `スコア: ${score}`;
                        break;
                    }
                }
            }
            
            const playerBounds = {
                x: player.x - player.size/2,
                y: player.y - player.size/2,
                width: player.size,
                height: player.size
            };
            
            for (let enemy of enemies) {
                if (checkCollision(playerBounds, enemy.getBounds())) {
                    gameOver();
                    return;
                }
            }
            
            if (Math.random() < 0.03) {
                spawnEnemy();
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < 50; i++) {
                const baseX = (Math.sin(Date.now() * 0.001 + i) * 200 + canvas.width/2 + i * 15) % canvas.width;
                const y = (Date.now() * 0.1 + i * 10) % canvas.height;
                
                if (isInVisibleArea(y)) {
                    const x = getPerspectiveX(baseX, canvas.height, y, 0.1);
                    const size = Math.random() * 2 * get3DScale(y);
                    ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.8})`;
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            enemies.forEach(enemy => enemy.draw());
            bullets.forEach(bullet => bullet.draw());
            particles.forEach(particle => particle.draw());
            drawPlayer();
        }
        
        // ゲームループ
        function gameLoop() {
            const gameUI = document.getElementById('gameUI');
            if (currentState === GameState.PLAYING) {
                gameUI.classList.remove('hidden');
            } else {
                gameUI.classList.add('hidden');
            }
            
            handleInput();
            
            if (currentState === GameState.TITLE) {
                drawTitle();
            } else if (currentState === GameState.PLAYING) {
                update();
                draw();
            } else if (currentState === GameState.GAMEOVER) {
                draw();
                drawGameOver();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // イベントリスナー（グローバルスコープで定義）
        document.addEventListener('keydown', function(e) {
            console.log('Key pressed:', e.key, 'State:', currentState);
            keys[e.key] = true;
            
            if (currentState === GameState.TITLE) {
                startGame();
            } else if (currentState === GameState.PLAYING) {
                if (e.key === ' ') {
                    e.preventDefault();
                    bullets.push(new Bullet(player.x - 8, player.y - player.size/2));
                    bullets.push(new Bullet(player.x + 8, player.y - player.size/2));
                }
            } else if (currentState === GameState.GAMEOVER) {
                startGame();
            }
        });
        
        document.addEventListener('keyup', function(e) {
            keys[e.key] = false;
        });
        
        document.addEventListener('click', function(e) {
            console.log('Click detected, State:', currentState);
            if (currentState === GameState.TITLE) {
                startGame();
            } else if (currentState === GameState.GAMEOVER) {
                startGame();
            }
        });
        
        // ゲーム初期化と開始
        document.getElementById('gameUI').classList.add('hidden');
        gameLoop();
    </script>
</body>
</html>